{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rustus is a TUS protocol implementation that helps you handle file uploads. This project has many features that makes it easy to integrate in your service. Installation You can install rustus by 4 different ways. From source To build it from source rust must be installed. Preferred version is 1.59.0. git clone https://github.com/s3rius/rustus.git cd rustus cargo install --path . --features = all Also you can speedup build by disabling some features. Available features: amqp_notifier - adds amqp protocol support for notifying about upload status; db_info_storage - adds support for storing information about upload in different databases (Postgres, MySQL, SQLite); http_notifier - adds support for notifying about upload status via http protocol; redis_info_storage - adds support for storing information about upload in redis database; hashers - adds support for checksum verification; all - enables all rustus features. All precompiled binaries have all features enabled. With cargo If you have cargo installed maybe it would be easier to install it directly from crates.io. cargo install rustus --features = all Binaries All precompiled binaries available on github releases page. You can download binaries from here , unpack it and run. ./rustus Make sure that you download version for your cpu and os. Using docker One of the most simple ways to run rustus is docker. Rustus has two containers for each version. 1. debian based image 2. alpine based image Alpine based images are more lightweight than debian To run rustus you just need to run this command docker run --rm -p \"1081:1081\" -d s3rius/rustus --log-level \"DEBUG\"","title":"Welcome page"},{"location":"#installation","text":"You can install rustus by 4 different ways.","title":"Installation"},{"location":"#from-source","text":"To build it from source rust must be installed. Preferred version is 1.59.0. git clone https://github.com/s3rius/rustus.git cd rustus cargo install --path . --features = all Also you can speedup build by disabling some features. Available features: amqp_notifier - adds amqp protocol support for notifying about upload status; db_info_storage - adds support for storing information about upload in different databases (Postgres, MySQL, SQLite); http_notifier - adds support for notifying about upload status via http protocol; redis_info_storage - adds support for storing information about upload in redis database; hashers - adds support for checksum verification; all - enables all rustus features. All precompiled binaries have all features enabled.","title":"From source"},{"location":"#with-cargo","text":"If you have cargo installed maybe it would be easier to install it directly from crates.io. cargo install rustus --features = all","title":"With cargo"},{"location":"#binaries","text":"All precompiled binaries available on github releases page. You can download binaries from here , unpack it and run. ./rustus Make sure that you download version for your cpu and os.","title":"Binaries"},{"location":"#using-docker","text":"One of the most simple ways to run rustus is docker. Rustus has two containers for each version. 1. debian based image 2. alpine based image Alpine based images are more lightweight than debian To run rustus you just need to run this command docker run --rm -p \"1081:1081\" -d s3rius/rustus --log-level \"DEBUG\"","title":"Using docker"},{"location":"configuration/","text":"Rustus is highly configurable you can configure rustus with CLI or you can use environment variables. Info Some options can be passed only through as CLI parameters Info Information about hooks you can find on Hooks page . Configuring server We use actix to run server. You can configure on wich host and port rustus is listenging. Also you can configure number of actix workers that handle connections. --max-body-size is the max number of bytes that users can send in request body. --url is a base URL for all tus requests. --workers by default is euqal to number of physical CPU cores. Edit it carefully. CLI ENV rustus --host \"0.0.0.0\" \\ --port 1081 \\ --workers 8 \\ --max-body-size 1000000 \\ --url \"/files\" \\ --log-level \"INFO\" export RUSTUS_SERVER_HOST = \"0.0.0.0\" export RUSTUS_SERVER_PORT = \"1081\" export RUSTUS_SERVER_WORKERS = \"8\" export RUSTUS_MAX_BODY_SIZE = \"1000000\" export RUSTUS_URL = \"/files\" export RUSTUS_LOG_LEVEL = \"INFO\" rustus Configuring data storage Info Currently only file storage is available, so if you pass to --storage parameter other than file-storage you will get an error. Also you can not pass --force-fsync through environment variables. --storage is a type of data storage to be used. --data-dir is a path to the directory where all files are stored. --dir-structure is a pattern of a directory structure inside data dir. You can use variables within the pattern. Available variables: {year} - current year; {month} - current month number from 1 to 12; {day} - current day number from 1 to 31; {hour} - hour number from 0 to 23; {minute} - minute number from 0 to 59; {env[ENV_NAME]} - environment variable where ENV_NAME is name of your variable. Note All environment variables are saved in memory during rustus startup. So you cannot change variable dynamically. Even if you change env used in structure pattern it won't change. For example if you use {env[HOSTNAME]}/{year}/{month}/{day} as your dir-structure, rustus stores files like: $ tree data data \u2514\u2500\u2500 rtus-68cb5b8746-5mgw9 \u2514\u2500\u2500 2022 \u2514\u2500\u2500 1 \u2514\u2500\u2500 8 \u251c\u2500\u2500 0bd911d4054d41c6a3ad54be67ee3e66 \u2514\u2500\u2500 5bc9c62384494c439e2a064b82a39cc6 CLI ENV rustus --force-fsync \\ --storage \"file-storage\" \\ --data-dir \"./data/\" \\ --dir-structure \"{year}/{month}/{day}\" export RUSTUS_STORAGE = \"file-storage\" export RUSTUS_DATA_DIR = \"./data/\" export RUSTUS_DIR_STRUCTURE = \"{year}/{month}/{day}\" rustus --force-fsync Configuring info storage Info storages are used to store information about file uploads. These storages must be persistent, because every time chunk is uploaded rustus updates information about upload. And when someone wants to download file, information about it requested from storage to get actual path of an upload. Available info storages: file-info-storage - stores information in files on disk; redis-info-storage - information is stored in redis; db-info-storage - information is stored in database; File info storage file info storage stores information in files on disk. It's default info storage. Every download has it's own associated file. All .info files stored in flat structure so it's the least preferable way of storing information about uploads. But if you don't plan to have many uploads, it may fit well. --info-dir - directory where all .info file will be stored (default is ./data ). CLI ENV rustus --force-fsync \\ --storage \"file-info-storage\" \\ --info-dir \"./data\" export RUSTUS_INFO_STORAGE = \"file-info-storage\" export RUSTUS_INFO_DIR = \"./data\" rustus Redis info storage Redis db is a good way to store information. Note If you're using redis as a cluster you must provide connection string for master redis server. Since rustus need to have latest information and it writes a lot. --info-db-dsn - connection string for your redis database. It's required if redis-info-storage is chosen. CLI ENV rustus --force-fsync \\ --storage \"redis-info-storage\" \\ --info-db-dsn \"redis://localhost/0\" export RUSTUS_INFO_STORAGE = \"redis-info-storage\" export RUSTUS_INFO_DB_DSN = \"redis://localhost\" rustus DB info storage Rustus can store information about upload in database. It's a good and reliable option. But rustus can't work with replicas since it requires most recent information about uploads. You can use postgresql , mysql or even sqlite schemas to connect to database. --info-db-dsn - connection string for your database. CLI ENV rustus --force-fsync \\ --storage \"db-info-storage\" \\ --info-db-dsn \"postgresql://user:password@localhost/db\" export RUSTUS_INFO_STORAGE = \"redis-info-storage\" export RUSTUS_INFO_DB_DSN = \"postgresql://user:password@localhost/db\" rustus Configuring TUS Since tus protocol offers extensibility you can turn off some protocol extensions. Available extensions: getting - rustus specific extension that helps you download uploaded files with get request; creation - helps you to create files (It's like a core feature you better have this enabled); termination - allows you to delete uploads with DELETE request; creation-with-upload - allows you to write first bytes of a file while creating; creation-defer-length - allows you to create file without specifying file length; concatenation - allows you to concatenate finished partial uploads. checksum - allows you to verify checksum of every batch. You can read more about extensions on official web-site . --tus-extensions - a list of enabled extensions. By default all extensions are enabled. CLI ENV rustus --tus-extensions \"getting,creation,termination,creation-with-upload,creation-defer-length,concatenation,checksum\" export RUSTUS_TUS_EXTENSIONS = \"getting,creation,termination,creation-with-upload,creation-defer-length,concatenation,checksum\" rustus","title":"Configuration"},{"location":"configuration/#configuring-server","text":"We use actix to run server. You can configure on wich host and port rustus is listenging. Also you can configure number of actix workers that handle connections. --max-body-size is the max number of bytes that users can send in request body. --url is a base URL for all tus requests. --workers by default is euqal to number of physical CPU cores. Edit it carefully. CLI ENV rustus --host \"0.0.0.0\" \\ --port 1081 \\ --workers 8 \\ --max-body-size 1000000 \\ --url \"/files\" \\ --log-level \"INFO\" export RUSTUS_SERVER_HOST = \"0.0.0.0\" export RUSTUS_SERVER_PORT = \"1081\" export RUSTUS_SERVER_WORKERS = \"8\" export RUSTUS_MAX_BODY_SIZE = \"1000000\" export RUSTUS_URL = \"/files\" export RUSTUS_LOG_LEVEL = \"INFO\" rustus","title":"Configuring server"},{"location":"configuration/#configuring-data-storage","text":"Info Currently only file storage is available, so if you pass to --storage parameter other than file-storage you will get an error. Also you can not pass --force-fsync through environment variables. --storage is a type of data storage to be used. --data-dir is a path to the directory where all files are stored. --dir-structure is a pattern of a directory structure inside data dir. You can use variables within the pattern. Available variables: {year} - current year; {month} - current month number from 1 to 12; {day} - current day number from 1 to 31; {hour} - hour number from 0 to 23; {minute} - minute number from 0 to 59; {env[ENV_NAME]} - environment variable where ENV_NAME is name of your variable. Note All environment variables are saved in memory during rustus startup. So you cannot change variable dynamically. Even if you change env used in structure pattern it won't change. For example if you use {env[HOSTNAME]}/{year}/{month}/{day} as your dir-structure, rustus stores files like: $ tree data data \u2514\u2500\u2500 rtus-68cb5b8746-5mgw9 \u2514\u2500\u2500 2022 \u2514\u2500\u2500 1 \u2514\u2500\u2500 8 \u251c\u2500\u2500 0bd911d4054d41c6a3ad54be67ee3e66 \u2514\u2500\u2500 5bc9c62384494c439e2a064b82a39cc6 CLI ENV rustus --force-fsync \\ --storage \"file-storage\" \\ --data-dir \"./data/\" \\ --dir-structure \"{year}/{month}/{day}\" export RUSTUS_STORAGE = \"file-storage\" export RUSTUS_DATA_DIR = \"./data/\" export RUSTUS_DIR_STRUCTURE = \"{year}/{month}/{day}\" rustus --force-fsync","title":"Configuring data storage"},{"location":"configuration/#configuring-info-storage","text":"Info storages are used to store information about file uploads. These storages must be persistent, because every time chunk is uploaded rustus updates information about upload. And when someone wants to download file, information about it requested from storage to get actual path of an upload. Available info storages: file-info-storage - stores information in files on disk; redis-info-storage - information is stored in redis; db-info-storage - information is stored in database;","title":"Configuring info storage"},{"location":"configuration/#file-info-storage","text":"file info storage stores information in files on disk. It's default info storage. Every download has it's own associated file. All .info files stored in flat structure so it's the least preferable way of storing information about uploads. But if you don't plan to have many uploads, it may fit well. --info-dir - directory where all .info file will be stored (default is ./data ). CLI ENV rustus --force-fsync \\ --storage \"file-info-storage\" \\ --info-dir \"./data\" export RUSTUS_INFO_STORAGE = \"file-info-storage\" export RUSTUS_INFO_DIR = \"./data\" rustus","title":"File info storage"},{"location":"configuration/#redis-info-storage","text":"Redis db is a good way to store information. Note If you're using redis as a cluster you must provide connection string for master redis server. Since rustus need to have latest information and it writes a lot. --info-db-dsn - connection string for your redis database. It's required if redis-info-storage is chosen. CLI ENV rustus --force-fsync \\ --storage \"redis-info-storage\" \\ --info-db-dsn \"redis://localhost/0\" export RUSTUS_INFO_STORAGE = \"redis-info-storage\" export RUSTUS_INFO_DB_DSN = \"redis://localhost\" rustus","title":"Redis info storage"},{"location":"configuration/#db-info-storage","text":"Rustus can store information about upload in database. It's a good and reliable option. But rustus can't work with replicas since it requires most recent information about uploads. You can use postgresql , mysql or even sqlite schemas to connect to database. --info-db-dsn - connection string for your database. CLI ENV rustus --force-fsync \\ --storage \"db-info-storage\" \\ --info-db-dsn \"postgresql://user:password@localhost/db\" export RUSTUS_INFO_STORAGE = \"redis-info-storage\" export RUSTUS_INFO_DB_DSN = \"postgresql://user:password@localhost/db\" rustus","title":"DB info storage"},{"location":"configuration/#configuring-tus","text":"Since tus protocol offers extensibility you can turn off some protocol extensions. Available extensions: getting - rustus specific extension that helps you download uploaded files with get request; creation - helps you to create files (It's like a core feature you better have this enabled); termination - allows you to delete uploads with DELETE request; creation-with-upload - allows you to write first bytes of a file while creating; creation-defer-length - allows you to create file without specifying file length; concatenation - allows you to concatenate finished partial uploads. checksum - allows you to verify checksum of every batch. You can read more about extensions on official web-site . --tus-extensions - a list of enabled extensions. By default all extensions are enabled. CLI ENV rustus --tus-extensions \"getting,creation,termination,creation-with-upload,creation-defer-length,concatenation,checksum\" export RUSTUS_TUS_EXTENSIONS = \"getting,creation,termination,creation-with-upload,creation-defer-length,concatenation,checksum\" rustus","title":"Configuring TUS"},{"location":"deploy/","text":"Deployment Deploying an application is always a challenge. Rustus was made to make deployment as easy as possible. Since this application works with files so if you want to scale number of rustus instances you have to somehow make different rustus instances to work with the same data or info directory. Docker compose docker-compose.yml # This is super simple configuration version : \"3.7\" services : rustus : image : s3rius/rustus volumes : # Volume mouted to default data directory # So it's available across multiple containers. - rustus_data_volume:/app/data volumes : rustus_data_volume : After running docker compose up you will see rustus startup logs. If you want to deploy multiple rustus instances you can simply use config as this one: docker-compose.yml version : \"3.7\" services : proxy : image : jwilder/nginx-proxy:alpine container_name : proxy # Actual proxy ports. ports : - 8080:80 volumes : # This thing helps to locate containers # within this composition to generate nginx config. - /var/run/docker.sock:/tmp/docker.sock:ro rustus : image : s3rius/rustus ports : # Ports definition # To generate correct nginx config. - 1081 volumes : # Volume mouted to default data directory # So it's available across multiple containers. - rustus_data_volume:/app/data environment : # Idk why but without this variable # load balancing with jwilder/nginx-proxy doesn't work. VIRTUAL_HOST : localhost volumes : rustus_data_volume : # This is named volume The main idea is that traffic that comes into nginx-proxy is routed in one of multiple rustus containers. Here I used jwilder/nginx-proxy but you can use other reverse-proxies such as raw nginx proxy or traefik . Now you can run multiple rustus instnaces like this. docker compose up --scale rustus = 3 After that you can upload files to http://localhost:8080/files Kubernetes Configuration for kubernetes is almost the same as docker. But the most preferable way is an official helm chart. Load balancing is done by kubernetes so you just have to create volume to mount data and info directories. Helm You can install rustus by running this set of commands: helm repo add \"rustus\" \"https://s3rius.github.io/rustus/helm_releases\" helm repo update helm repo install \"rustus/rustus\" Configuration But of course it can be configured. # You can download basic configuration by running helm show values \"rustus/rustus\" > values.yml By editing values.yml you can configure many different options. Warning For production use you must provide and mount PersistentVolumeClaim in order to scale rustus. This helm chart has only one replica by default. Persistence You can add pvc mount by editing persistence section. The most preferable way is to create PersistentVolume and PersistentVolumeClaim before installing this chart. After you created claim you can apply this values file to mount your claim into rustus. values.yml persistence : enabled : true existingClaim : \"rustus-pvc\" Warning Currently there's no ability to create multiple mounts and if you use file info storage you must specify the same direcotry as you specified for data storage. But it would be better to use other type of info-storage. Subcharts For example if you want to use redis as your info storage. values.yml env : RUSTUS_INFO_STORAGE : redis-info-storage RUSTUS_INFO_DB_DSN : redis://:pass@rustus-redis-master/0 redis : enabled : true redis , postgersql and mysql are subcharts. You can find information about configuration these subcharts here: Repo for redis; Repo for mysql; Repo for postgresql. In production you may ignore these subcharts to deploy your own redis or mysql or postgresql. After you done editing values.yml you can apply the configuration like this: helm upgrade \\ --install \\ # Install chart if it's not installed --namespace rustus \\ # k8s namespace --create-namespace \\ # Creates namespace if it doesn't exist --atomic \\ # Ensures that everything is deployed correctly --values \"values.yml\" \\ # Link to values.yml file \"rustus\" \\ # name of a release \"rustus/rustus\" # Name of the chart","title":"Deployment"},{"location":"deploy/#deployment","text":"Deploying an application is always a challenge. Rustus was made to make deployment as easy as possible. Since this application works with files so if you want to scale number of rustus instances you have to somehow make different rustus instances to work with the same data or info directory.","title":"Deployment"},{"location":"deploy/#docker-compose","text":"docker-compose.yml # This is super simple configuration version : \"3.7\" services : rustus : image : s3rius/rustus volumes : # Volume mouted to default data directory # So it's available across multiple containers. - rustus_data_volume:/app/data volumes : rustus_data_volume : After running docker compose up you will see rustus startup logs. If you want to deploy multiple rustus instances you can simply use config as this one: docker-compose.yml version : \"3.7\" services : proxy : image : jwilder/nginx-proxy:alpine container_name : proxy # Actual proxy ports. ports : - 8080:80 volumes : # This thing helps to locate containers # within this composition to generate nginx config. - /var/run/docker.sock:/tmp/docker.sock:ro rustus : image : s3rius/rustus ports : # Ports definition # To generate correct nginx config. - 1081 volumes : # Volume mouted to default data directory # So it's available across multiple containers. - rustus_data_volume:/app/data environment : # Idk why but without this variable # load balancing with jwilder/nginx-proxy doesn't work. VIRTUAL_HOST : localhost volumes : rustus_data_volume : # This is named volume The main idea is that traffic that comes into nginx-proxy is routed in one of multiple rustus containers. Here I used jwilder/nginx-proxy but you can use other reverse-proxies such as raw nginx proxy or traefik . Now you can run multiple rustus instnaces like this. docker compose up --scale rustus = 3 After that you can upload files to http://localhost:8080/files","title":"Docker compose"},{"location":"deploy/#kubernetes","text":"Configuration for kubernetes is almost the same as docker. But the most preferable way is an official helm chart. Load balancing is done by kubernetes so you just have to create volume to mount data and info directories.","title":"Kubernetes"},{"location":"deploy/#helm","text":"You can install rustus by running this set of commands: helm repo add \"rustus\" \"https://s3rius.github.io/rustus/helm_releases\" helm repo update helm repo install \"rustus/rustus\"","title":"Helm"},{"location":"deploy/#configuration","text":"But of course it can be configured. # You can download basic configuration by running helm show values \"rustus/rustus\" > values.yml By editing values.yml you can configure many different options. Warning For production use you must provide and mount PersistentVolumeClaim in order to scale rustus. This helm chart has only one replica by default.","title":"Configuration"},{"location":"deploy/#persistence","text":"You can add pvc mount by editing persistence section. The most preferable way is to create PersistentVolume and PersistentVolumeClaim before installing this chart. After you created claim you can apply this values file to mount your claim into rustus. values.yml persistence : enabled : true existingClaim : \"rustus-pvc\" Warning Currently there's no ability to create multiple mounts and if you use file info storage you must specify the same direcotry as you specified for data storage. But it would be better to use other type of info-storage.","title":"Persistence"},{"location":"deploy/#subcharts","text":"For example if you want to use redis as your info storage. values.yml env : RUSTUS_INFO_STORAGE : redis-info-storage RUSTUS_INFO_DB_DSN : redis://:pass@rustus-redis-master/0 redis : enabled : true redis , postgersql and mysql are subcharts. You can find information about configuration these subcharts here: Repo for redis; Repo for mysql; Repo for postgresql. In production you may ignore these subcharts to deploy your own redis or mysql or postgresql. After you done editing values.yml you can apply the configuration like this: helm upgrade \\ --install \\ # Install chart if it's not installed --namespace rustus \\ # k8s namespace --create-namespace \\ # Creates namespace if it doesn't exist --atomic \\ # Ensures that everything is deployed correctly --values \"values.yml\" \\ # Link to values.yml file \"rustus\" \\ # name of a release \"rustus/rustus\" # Name of the chart","title":"Subcharts"},{"location":"hooks/","text":"Rustus can notify about uploads using hooks. This is useful when you integrate rustus in your architecture. Apps can keep track of every upload using this feature. Rustus has different event types for different moments of an upload's lifecycle. pre-create - This hook means that someone wants to create an upload; post-create - someone successfully created an upload; post-receive - someone uploaded a new part of an upload; post-terminate - someone deleted upload; post-finish - someone finished uploading file. Note Pre-create hook is very important. If at least one of hooks fails, upload is canceled. But AMQP hooks won't cancel the upload, since it's non blocking type of hooks. You can disable some hooks by using --hooks parameter. CLI ENV rustus --hooks \"pre-create,post-create,post-receive,post-terminate,post-finish\" export RUSTUS_HOOKS = \"pre-create,post-create,post-receive,post-terminate,post-finish\" rustus Fomat Information about every hook using JSON format. Format can be configured using --hooks-format parameter or RUSTUS_HOOKS_FORMAT environment variable. Available formats: default tusd default tusd { \"upload\" : { \"id\" : \"\" , \"offset\" : 0 , \"length\" : 39729945 , \"path\" : null , \"created_at\" : 1641620821 , \"deferred_size\" : false , \"metadata\" : { \"filename\" : \"38MB_video.mp4\" , \"meme\" : \"hehe2\" } }, \"request\" : { \"URI\" : \"/files\" , \"method\" : \"POST\" , \"remote_addr\" : \"127.0.0.1\" , \"headers\" : { \"accept-encoding\" : \"gzip, deflate\" , \"connection\" : \"keep-alive\" , \"host\" : \"localhost:1081\" , \"upload-metadata\" : \"meme aGVoZTI=,filename MzhNQl92aWRlby5tcDQ=\" , \"tus-resumable\" : \"1.0.0\" , \"content-length\" : \"0\" , \"upload-length\" : \"39729945\" , \"user-agent\" : \"python-requests/2.26.0\" , \"accept\" : \"*/*\" } } } { \"Upload\" : { \"ID\" : \"\" , \"Offset\" : 0 , \"Size\" : 39729945 , \"IsFinal\" : true , \"IsPartial\" : false , \"PartialUploads\" : null , \"SizeIsDeferred\" : false , \"Metadata\" : { \"filename\" : \"38MB_video.mp4\" , \"meme\" : \"hehe2\" }, \"Storage\" : { \"Type\" : \"filestore\" , \"Path\" : null } }, \"HTTPRequest\" : { \"URI\" : \"/files\" , \"Method\" : \"POST\" , \"RemoteAddr\" : \"127.0.0.1\" , \"Header\" : { \"host\" : [ \"localhost:1081\" ], \"user-agent\" : [ \"python-requests/2.26.0\" ], \"accept\" : [ \"*/*\" ], \"content-length\" : [ \"0\" ], \"upload-metadata\" : [ \"meme aGVoZTI=,filename MzhNQl92aWRlby5tcDQ=\" ], \"connection\" : [ \"keep-alive\" ], \"tus-resumable\" : [ \"1.0.0\" ], \"upload-length\" : [ \"39729945\" ], \"accept-encoding\" : [ \"gzip, deflate\" ] } } } Hook types Rustus offers multiple types of Hooks. We'll take a brief look on each type. File hooks Rustus can work with two types of file hooks. Single file hook Hooks directory The main difference is that in case if use single file hook, hook name is passed as a command line argument to an executable file, but if you use hooks directory then hook name is used to determine a file to call. Let's take a look at the examples. Parameters: * --hooks-file - path to an executable file; * --hooks-dir - path to a directory with executable files. single_file_hook.sh #!/bin/bash # Hook name would be \"pre-create\", \"post-create\" and so on. HOOK_NAME = \" $1 \" HOOK_INFO = \" $2 \" MEME = \" $( echo \" $HOOK_INFO \" | jq \".upload .metadata .meme\" | xargs ) \" # Here we check if name in metadata is equal to pepe. if [[ $MEME = \"pepe\" ]] ; then echo \"This meme isn't allowed\" 1 > & 2 ; exit 1 fi As you can see it uses first CLI parameter as a hook name and all hook data is received from the second one. Let's make it executable and make rustus use this hook. CLI ENV chmod +x \"hooks/single_file_hook.sh\" rustus --hooks-file \"hooks/single_file_hook.sh\" chmod +x \"hooks/single_file_hook.sh\" export RUSTUS_HOOKS_FILE = \"hooks/single_file_hook.sh\" rustus If you would like to use directory hooks you must create directory with the following structure: hooks \u251c\u2500\u2500 post-create \u251c\u2500\u2500 post-finish \u251c\u2500\u2500 post-receive \u251c\u2500\u2500 post-terminate \u2514\u2500\u2500 pre-create Warning If some hook file isn't found, rustus throws an error. In case with pre-create hook it can be fatal. Http Hooks Http hooks use HTTP to send POST requests to some endpoint. Configuration parameters: --hooks-http-proxy-headers - list of headers to proxy (separated by commas) to listener's endpoint; --hooks-http-urls - list of absolute urls to send request to (separated by commas). Note Hook names are passed as header called Hook-Name . CLI ENV rustus --hooks-http-urls \"https://httpbin.org/post\" \\ --hooks-http-proxy-headers \"Authorization\" export RUSTUS_HOOKS_HTTP_URLS = \"https://httpbin.org/post\" export RUSTUS_HOOKS_HTTP_PROXY_HEADERS = \"Authorization\" rustus Example application To be more verbose let's create simple web server that handles uploads using FastAPI . At first we need to install dependencies using pip. pip install fastapi uvicorn server.py from fastapi import FastAPI , Header , HTTPException from typing import Optional app = FastAPI () @app . post ( \"/hooks\" ) def hook ( authorization : Optional [ str ] = Header ( None ), hook_name : Optional [ str ] = Header ( None ), ): print ( f \"Received: { hook_name } \" ) if authorization != \"Bearer jwt\" : raise HTTPException ( 401 ) return None Now we can run this server using uvicorn. uvicorn server:app --port 8080 Let's configure rustus to use this server as a hook reciever. CLI ENV rustus --hooks-http-urls \"http://localhost:8000/hooks\" \\ --hooks-http-proxy-headers \"Authorization\" export RUSTUS_HOOKS_HTTP_URLS = \"http://localhost:8000/hooks\" export RUSTUS_HOOKS_HTTP_PROXY_HEADERS = \"Authorization\" rustus That's it. AMQP hooks AMQP hooks are used to store information about uploads using RabbitMQ. Configuration parameters: --hooks-amqp-url - connection string to RabbitMQ; --hooks-amqp-queues-prefix - prefix for queues for every event queue; --hooks-amqp-exchange - name of exchange to use. This hook will send every message in an exchange with routing keys like queues names. Queues are named like {prefix}.{event type} . Eg rustus.pre-create and so on. Warning Since we can't really track message delivery and responses Rustus doesn't stop in any case. CLI ENV rustus --hooks-amqp-url \"amqp://guest:guest@localhost:5672\" \\ --hooks-amqp-queues-prefix \"rustus_queue\" \\ --hooks-amqp-exchange \"rustus\" export RUSTUS_HOOKS_AMQP_URL = \"amqp://guest:guest@localhost:5672\" export RUSTUS_HOOKS_AMQP_QUEUES_PREFIX = \"rustus_queue\" export RUSTUS_HOOKS_AMQP_EXCHANGE = \"rustus\" rustus","title":"Setting up hooks"},{"location":"hooks/#fomat","text":"Information about every hook using JSON format. Format can be configured using --hooks-format parameter or RUSTUS_HOOKS_FORMAT environment variable. Available formats: default tusd default tusd { \"upload\" : { \"id\" : \"\" , \"offset\" : 0 , \"length\" : 39729945 , \"path\" : null , \"created_at\" : 1641620821 , \"deferred_size\" : false , \"metadata\" : { \"filename\" : \"38MB_video.mp4\" , \"meme\" : \"hehe2\" } }, \"request\" : { \"URI\" : \"/files\" , \"method\" : \"POST\" , \"remote_addr\" : \"127.0.0.1\" , \"headers\" : { \"accept-encoding\" : \"gzip, deflate\" , \"connection\" : \"keep-alive\" , \"host\" : \"localhost:1081\" , \"upload-metadata\" : \"meme aGVoZTI=,filename MzhNQl92aWRlby5tcDQ=\" , \"tus-resumable\" : \"1.0.0\" , \"content-length\" : \"0\" , \"upload-length\" : \"39729945\" , \"user-agent\" : \"python-requests/2.26.0\" , \"accept\" : \"*/*\" } } } { \"Upload\" : { \"ID\" : \"\" , \"Offset\" : 0 , \"Size\" : 39729945 , \"IsFinal\" : true , \"IsPartial\" : false , \"PartialUploads\" : null , \"SizeIsDeferred\" : false , \"Metadata\" : { \"filename\" : \"38MB_video.mp4\" , \"meme\" : \"hehe2\" }, \"Storage\" : { \"Type\" : \"filestore\" , \"Path\" : null } }, \"HTTPRequest\" : { \"URI\" : \"/files\" , \"Method\" : \"POST\" , \"RemoteAddr\" : \"127.0.0.1\" , \"Header\" : { \"host\" : [ \"localhost:1081\" ], \"user-agent\" : [ \"python-requests/2.26.0\" ], \"accept\" : [ \"*/*\" ], \"content-length\" : [ \"0\" ], \"upload-metadata\" : [ \"meme aGVoZTI=,filename MzhNQl92aWRlby5tcDQ=\" ], \"connection\" : [ \"keep-alive\" ], \"tus-resumable\" : [ \"1.0.0\" ], \"upload-length\" : [ \"39729945\" ], \"accept-encoding\" : [ \"gzip, deflate\" ] } } }","title":"Fomat"},{"location":"hooks/#hook-types","text":"Rustus offers multiple types of Hooks. We'll take a brief look on each type.","title":"Hook types"},{"location":"hooks/#file-hooks","text":"Rustus can work with two types of file hooks. Single file hook Hooks directory The main difference is that in case if use single file hook, hook name is passed as a command line argument to an executable file, but if you use hooks directory then hook name is used to determine a file to call. Let's take a look at the examples. Parameters: * --hooks-file - path to an executable file; * --hooks-dir - path to a directory with executable files. single_file_hook.sh #!/bin/bash # Hook name would be \"pre-create\", \"post-create\" and so on. HOOK_NAME = \" $1 \" HOOK_INFO = \" $2 \" MEME = \" $( echo \" $HOOK_INFO \" | jq \".upload .metadata .meme\" | xargs ) \" # Here we check if name in metadata is equal to pepe. if [[ $MEME = \"pepe\" ]] ; then echo \"This meme isn't allowed\" 1 > & 2 ; exit 1 fi As you can see it uses first CLI parameter as a hook name and all hook data is received from the second one. Let's make it executable and make rustus use this hook. CLI ENV chmod +x \"hooks/single_file_hook.sh\" rustus --hooks-file \"hooks/single_file_hook.sh\" chmod +x \"hooks/single_file_hook.sh\" export RUSTUS_HOOKS_FILE = \"hooks/single_file_hook.sh\" rustus If you would like to use directory hooks you must create directory with the following structure: hooks \u251c\u2500\u2500 post-create \u251c\u2500\u2500 post-finish \u251c\u2500\u2500 post-receive \u251c\u2500\u2500 post-terminate \u2514\u2500\u2500 pre-create Warning If some hook file isn't found, rustus throws an error. In case with pre-create hook it can be fatal.","title":"File hooks"},{"location":"hooks/#http-hooks","text":"Http hooks use HTTP to send POST requests to some endpoint. Configuration parameters: --hooks-http-proxy-headers - list of headers to proxy (separated by commas) to listener's endpoint; --hooks-http-urls - list of absolute urls to send request to (separated by commas). Note Hook names are passed as header called Hook-Name . CLI ENV rustus --hooks-http-urls \"https://httpbin.org/post\" \\ --hooks-http-proxy-headers \"Authorization\" export RUSTUS_HOOKS_HTTP_URLS = \"https://httpbin.org/post\" export RUSTUS_HOOKS_HTTP_PROXY_HEADERS = \"Authorization\" rustus","title":"Http Hooks"},{"location":"hooks/#example-application","text":"To be more verbose let's create simple web server that handles uploads using FastAPI . At first we need to install dependencies using pip. pip install fastapi uvicorn server.py from fastapi import FastAPI , Header , HTTPException from typing import Optional app = FastAPI () @app . post ( \"/hooks\" ) def hook ( authorization : Optional [ str ] = Header ( None ), hook_name : Optional [ str ] = Header ( None ), ): print ( f \"Received: { hook_name } \" ) if authorization != \"Bearer jwt\" : raise HTTPException ( 401 ) return None Now we can run this server using uvicorn. uvicorn server:app --port 8080 Let's configure rustus to use this server as a hook reciever. CLI ENV rustus --hooks-http-urls \"http://localhost:8000/hooks\" \\ --hooks-http-proxy-headers \"Authorization\" export RUSTUS_HOOKS_HTTP_URLS = \"http://localhost:8000/hooks\" export RUSTUS_HOOKS_HTTP_PROXY_HEADERS = \"Authorization\" rustus That's it.","title":"Example application"},{"location":"hooks/#amqp-hooks","text":"AMQP hooks are used to store information about uploads using RabbitMQ. Configuration parameters: --hooks-amqp-url - connection string to RabbitMQ; --hooks-amqp-queues-prefix - prefix for queues for every event queue; --hooks-amqp-exchange - name of exchange to use. This hook will send every message in an exchange with routing keys like queues names. Queues are named like {prefix}.{event type} . Eg rustus.pre-create and so on. Warning Since we can't really track message delivery and responses Rustus doesn't stop in any case. CLI ENV rustus --hooks-amqp-url \"amqp://guest:guest@localhost:5672\" \\ --hooks-amqp-queues-prefix \"rustus_queue\" \\ --hooks-amqp-exchange \"rustus\" export RUSTUS_HOOKS_AMQP_URL = \"amqp://guest:guest@localhost:5672\" export RUSTUS_HOOKS_AMQP_QUEUES_PREFIX = \"rustus_queue\" export RUSTUS_HOOKS_AMQP_EXCHANGE = \"rustus\" rustus","title":"AMQP hooks"}]}