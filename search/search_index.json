{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rustus is a TUS protocol implementation that helps you handle file uploads. This project has many features that makes it easy to integrate in your service. Installation You can install rustus by 4 different ways. From source To build it from source rust must be installed. Preferred version is 1.59.0. git clone https://github.com/s3rius/rustus.git cd rustus cargo install --path . --features = all Also you can speedup build by disabling some features. Available features: amqp_notifier - adds amqp protocol support for notifying about upload status; db_info_storage - adds support for storing information about upload in different databases (Postgres, MySQL, SQLite); http_notifier - adds support for notifying about upload status via http protocol; redis_info_storage - adds support for storing information about upload in redis database; hashers - adds support for checksum verification; all - enables all rustus features. All precompiled binaries have all features enabled. With cargo If you have cargo installed maybe it would be easier to install it directly from crates.io. cargo install rustus --features = all Binaries All precompiled binaries available on github releases page. You can download binaries from here , unpack it and run. ./rustus Make sure that you download version for your cpu and os. Using docker One of the most simple ways to run rustus is docker. Rustus has two containers for each version. 1. debian based image 2. alpine based image Alpine based images are more lightweight than debian To run rustus you just need to run this command docker run --rm -p \"1081:1081\" -d s3rius/rustus --log-level \"DEBUG\"","title":"Welcome page"},{"location":"#installation","text":"You can install rustus by 4 different ways.","title":"Installation"},{"location":"#from-source","text":"To build it from source rust must be installed. Preferred version is 1.59.0. git clone https://github.com/s3rius/rustus.git cd rustus cargo install --path . --features = all Also you can speedup build by disabling some features. Available features: amqp_notifier - adds amqp protocol support for notifying about upload status; db_info_storage - adds support for storing information about upload in different databases (Postgres, MySQL, SQLite); http_notifier - adds support for notifying about upload status via http protocol; redis_info_storage - adds support for storing information about upload in redis database; hashers - adds support for checksum verification; all - enables all rustus features. All precompiled binaries have all features enabled.","title":"From source"},{"location":"#with-cargo","text":"If you have cargo installed maybe it would be easier to install it directly from crates.io. cargo install rustus --features = all","title":"With cargo"},{"location":"#binaries","text":"All precompiled binaries available on github releases page. You can download binaries from here , unpack it and run. ./rustus Make sure that you download version for your cpu and os.","title":"Binaries"},{"location":"#using-docker","text":"One of the most simple ways to run rustus is docker. Rustus has two containers for each version. 1. debian based image 2. alpine based image Alpine based images are more lightweight than debian To run rustus you just need to run this command docker run --rm -p \"1081:1081\" -d s3rius/rustus --log-level \"DEBUG\"","title":"Using docker"},{"location":"configuration/","text":"Rustus is highly configurable you can configure rustus with CLI or you can use environment variables. Info Some options can be passed only through as CLI parameters Configuring data storage Configuring info storage Configuring hooks storage Configuring TUS","title":"Configuration"},{"location":"configuration/#configuring-data-storage","text":"","title":"Configuring data storage"},{"location":"configuration/#configuring-info-storage","text":"","title":"Configuring info storage"},{"location":"configuration/#configuring-hooks-storage","text":"","title":"Configuring hooks storage"},{"location":"configuration/#configuring-tus","text":"","title":"Configuring TUS"},{"location":"deploy/","text":"Deployment Deploying an application is always a challenge. Rustus was made to make deployment as easy as possible. Since this application works with files so if you want to scale number of rustus instances you have to somehow make different rustus instances to work with the same data or info directory. Docker compose docker-compose.yml # This is super simple configuration version : \"3.7\" services : rustus : image : s3rius/rustus volumes : # Volume mouted to default data directory # So it's available across multiple containers. - rustus_data_volume:/app/data volumes : rustus_data_volume : After running docker compose up you will see rustus startup logs. If you want to deploy multiple rustus instances you can simply use config as this one: docker-compose.yml version : \"3.7\" services : proxy : image : jwilder/nginx-proxy:alpine container_name : proxy # Actual proxy ports. ports : - 8080:80 volumes : # This thing helps to locate containers # within this composition to generate nginx config. - /var/run/docker.sock:/tmp/docker.sock:ro rustus : image : s3rius/rustus ports : # Ports definition # To generate correct nginx config. - 1081 volumes : # Volume mouted to default data directory # So it's available across multiple containers. - rustus_data_volume:/app/data environment : # Idk why but without this variable # load balancing with jwilder/nginx-proxy doesn't work. VIRTUAL_HOST : localhost volumes : rustus_data_volume : # This is named volume The main idea is that traffic that comes into nginx-proxy is routed in one of multiple rustus containers. Here I used jwilder/nginx-proxy but you can use other reverse-proxies such as raw nginx proxy or traefik . Now you can run multiple rustus instnaces like this. docker compose up --scale rustus = 3 After that you can upload files to http://localhost:8080/files Kubernetes Configuration for kubernetes is almost the same as docker. But the most preferable way is an official helm chart. Load balancing is done by kubernetes so you just have to create volume to mount data and info directories. Helm You can install rustus by running this set of commands: helm repo add \"rustus\" \"https://s3rius.github.io/rustus/helm_releases\" helm repo update helm repo install \"rustus/rustus\" Configuration But of course it can be configured. # You can download basic configuration by running helm show values \"rustus/rustus\" > values.yml By editing values.yml you can configure many different options. Warning For production use you must provide and mount PersistentVolumeClaim in order to scale rustus. This helm chart has only one replica by default. Persistence You can add pvc mount by editing persistence section. The most preferable way is to create PersistentVolume and PersistentVolumeClaim before installing this chart. After you created claim you can apply this values file to mount your claim into rustus. values.yml persistence : enabled : true existingClaim : \"rustus-pvc\" Warning Currently there's no ability to create multiple mounts and if you use file info storage you must specify the same direcotry as you specified for data storage. But it would be better to use other type of info-storage. Subcharts For example if you want to use redis as your info storage. values.yml env : RUSTUS_INFO_STORAGE : redis-info-storage RUSTUS_INFO_DB_DSN : redis://:pass@rustus-redis-master/0 redis : enabled : true redis , postgersql and mysql are subcharts. You can find information about configuration these subcharts here: Repo for redis; Repo for mysql; Repo for postgresql. In production you may ignore these subcharts to deploy your own redis or mysql or postgresql.","title":"Deployment"},{"location":"deploy/#deployment","text":"Deploying an application is always a challenge. Rustus was made to make deployment as easy as possible. Since this application works with files so if you want to scale number of rustus instances you have to somehow make different rustus instances to work with the same data or info directory.","title":"Deployment"},{"location":"deploy/#docker-compose","text":"docker-compose.yml # This is super simple configuration version : \"3.7\" services : rustus : image : s3rius/rustus volumes : # Volume mouted to default data directory # So it's available across multiple containers. - rustus_data_volume:/app/data volumes : rustus_data_volume : After running docker compose up you will see rustus startup logs. If you want to deploy multiple rustus instances you can simply use config as this one: docker-compose.yml version : \"3.7\" services : proxy : image : jwilder/nginx-proxy:alpine container_name : proxy # Actual proxy ports. ports : - 8080:80 volumes : # This thing helps to locate containers # within this composition to generate nginx config. - /var/run/docker.sock:/tmp/docker.sock:ro rustus : image : s3rius/rustus ports : # Ports definition # To generate correct nginx config. - 1081 volumes : # Volume mouted to default data directory # So it's available across multiple containers. - rustus_data_volume:/app/data environment : # Idk why but without this variable # load balancing with jwilder/nginx-proxy doesn't work. VIRTUAL_HOST : localhost volumes : rustus_data_volume : # This is named volume The main idea is that traffic that comes into nginx-proxy is routed in one of multiple rustus containers. Here I used jwilder/nginx-proxy but you can use other reverse-proxies such as raw nginx proxy or traefik . Now you can run multiple rustus instnaces like this. docker compose up --scale rustus = 3 After that you can upload files to http://localhost:8080/files","title":"Docker compose"},{"location":"deploy/#kubernetes","text":"Configuration for kubernetes is almost the same as docker. But the most preferable way is an official helm chart. Load balancing is done by kubernetes so you just have to create volume to mount data and info directories.","title":"Kubernetes"},{"location":"deploy/#helm","text":"You can install rustus by running this set of commands: helm repo add \"rustus\" \"https://s3rius.github.io/rustus/helm_releases\" helm repo update helm repo install \"rustus/rustus\"","title":"Helm"},{"location":"deploy/#configuration","text":"But of course it can be configured. # You can download basic configuration by running helm show values \"rustus/rustus\" > values.yml By editing values.yml you can configure many different options. Warning For production use you must provide and mount PersistentVolumeClaim in order to scale rustus. This helm chart has only one replica by default.","title":"Configuration"},{"location":"deploy/#persistence","text":"You can add pvc mount by editing persistence section. The most preferable way is to create PersistentVolume and PersistentVolumeClaim before installing this chart. After you created claim you can apply this values file to mount your claim into rustus. values.yml persistence : enabled : true existingClaim : \"rustus-pvc\" Warning Currently there's no ability to create multiple mounts and if you use file info storage you must specify the same direcotry as you specified for data storage. But it would be better to use other type of info-storage.","title":"Persistence"},{"location":"deploy/#subcharts","text":"For example if you want to use redis as your info storage. values.yml env : RUSTUS_INFO_STORAGE : redis-info-storage RUSTUS_INFO_DB_DSN : redis://:pass@rustus-redis-master/0 redis : enabled : true redis , postgersql and mysql are subcharts. You can find information about configuration these subcharts here: Repo for redis; Repo for mysql; Repo for postgresql. In production you may ignore these subcharts to deploy your own redis or mysql or postgresql.","title":"Subcharts"},{"location":"hooks/","text":"","title":"Hooks"}]}